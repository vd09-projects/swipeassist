// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: decisions.sql

package dbgen

import (
	"context"

	"github.com/vd09-projects/swipeassist/domain"
)

const getDecision = `-- name: GetDecision :one
SELECT
    id,
    profile_key,
    app,
    policy_name,
    action_kind,
    action_message,
    score,
    reason,
    created_at
FROM decisions
WHERE id = $1
`

func (q *Queries) GetDecision(ctx context.Context, id int64) (Decision, error) {
	row := q.db.QueryRow(ctx, getDecision, id)
	var i Decision
	err := row.Scan(
		&i.ID,
		&i.ProfileKey,
		&i.App,
		&i.PolicyName,
		&i.ActionKind,
		&i.ActionMessage,
		&i.Score,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const insertDecision = `-- name: InsertDecision :one

INSERT INTO decisions (
    profile_key,
    app,
    policy_name,
    action_kind,
    action_message,
    score,
    reason
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, profile_key, app, policy_name, action_kind, action_message, score, reason, created_at
`

type InsertDecisionParams struct {
	ProfileKey    *string              `json:"profile_key"`
	App           domain.AppName       `json:"app"`
	PolicyName    string               `json:"policy_name"`
	ActionKind    domain.AppActionType `json:"action_kind"`
	ActionMessage *string              `json:"action_message"`
	Score         int                  `json:"score"`
	Reason        string               `json:"reason"`
}

// Store and fetch decisions generated by the decision engine.
func (q *Queries) InsertDecision(ctx context.Context, arg InsertDecisionParams) (Decision, error) {
	row := q.db.QueryRow(ctx, insertDecision,
		arg.ProfileKey,
		arg.App,
		arg.PolicyName,
		arg.ActionKind,
		arg.ActionMessage,
		arg.Score,
		arg.Reason,
	)
	var i Decision
	err := row.Scan(
		&i.ID,
		&i.ProfileKey,
		&i.App,
		&i.PolicyName,
		&i.ActionKind,
		&i.ActionMessage,
		&i.Score,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const listDecisionsByProfile = `-- name: ListDecisionsByProfile :many
SELECT
    id,
    profile_key,
    app,
    policy_name,
    action_kind,
    action_message,
    score,
    reason,
    created_at
FROM decisions
WHERE profile_key = $1
ORDER BY created_at DESC
`

func (q *Queries) ListDecisionsByProfile(ctx context.Context, profileKey *string) ([]Decision, error) {
	rows, err := q.db.Query(ctx, listDecisionsByProfile, profileKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Decision
	for rows.Next() {
		var i Decision
		if err := rows.Scan(
			&i.ID,
			&i.ProfileKey,
			&i.App,
			&i.PolicyName,
			&i.ActionKind,
			&i.ActionMessage,
			&i.Score,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentDecisions = `-- name: ListRecentDecisions :many
SELECT
    id,
    profile_key,
    app,
    policy_name,
    action_kind,
    action_message,
    score,
    reason,
    created_at
FROM decisions
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListRecentDecisions(ctx context.Context, limit int32) ([]Decision, error) {
	rows, err := q.db.Query(ctx, listRecentDecisions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Decision
	for rows.Next() {
		var i Decision
		if err := rows.Scan(
			&i.ID,
			&i.ProfileKey,
			&i.App,
			&i.PolicyName,
			&i.ActionKind,
			&i.ActionMessage,
			&i.Score,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
